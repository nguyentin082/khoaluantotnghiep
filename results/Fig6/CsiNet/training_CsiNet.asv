% % Input:
% % H_train [64 x 160 x 40,000]
% % H_test [64 x 160 x 2,000]
% 
% clear; clc;
% rng(47);
% 
% % Parameters
% na = 64;                % # of BS antennas
% nc = 160;               % # of OFDM subcarriers
% nTrain = 40000;          % # of training samples
% nTest = 2000;           % # of test samples
% CR = 16;                % Compression ratio
% BTot = 256*5;           % Total feedback bits = 1280
% snrTrain = 10;          % Noise level in training samples. Value in linear units: -1=infdB or 1=0dB, 10=10dB, 1000=30dB
% snrTest = 10;           % Noise level in test samples. Value in linear units: -1=infdB or 1=0dB, 10=10dB, 1000=30dB
% 
% %% Import and preprocess data
% fprintf('Importing and preprocessing data...\n')
% 
% H_train = load('H_train_expanded.mat').H_train_expanded; % load scaled H_train_expanded.mat
% H_test = load('H_test.mat').H_test;
% 
% % UL Training
% HUL_train_n = H_train;
% Lambda = squeeze(1 ./ mean(abs(HUL_train_n).^2,[1 2])); % Tính Lambda
% if snrTrain ~= -1 % Thêm nhiễu Gaussian vào dữ liệu huấn luyện
%     nPower = 1 ./ (Lambda * snrTrain); % Tính công suất nhiễu
%     HN = bsxfun(@times, randn(na, nc, nTrain) + 1i * randn(na, nc, nTrain), reshape(sqrt(nPower / 2), 1, 1, [])); % Tạo nhiễu Gaussian
%     HUL_train_n = H_train + HN; % Thêm nhiễu vào ma trận kênh
%     Lambda = squeeze(1 ./ mean(abs(HUL_train_n).^2,[1 2])); % Tính lại Lambda
% end
% HUL_train_n = bsxfun(@times, HUL_train_n, reshape(sqrt(Lambda), 1, 1, [])); % Chuẩn hóa ma trận kênh
% HUL_train_compl_tmp = reshape(HUL_train_n, na * nc, nTrain).'; % Định dạng lại ma trận kênh
% HUL_train_compl_tmp_mean = mean(HUL_train_compl_tmp); % Tính giá trị trung bình
% HUL_train_compl = bsxfun(@minus, HUL_train_compl_tmp, HUL_train_compl_tmp_mean); % Trừ đi giá trị trung bình
% 
% % DL Testing
% HDL_test_n = H_test;
% Lambda = squeeze(1 ./ mean(abs(HDL_test_n).^2,[1 2])); % Tính Lambda
% HDL_test = bsxfun(@times, HDL_test_n, reshape(sqrt(Lambda), 1, 1, [])); % Chuẩn hóa ma trận kênh
% if snrTest ~= -1 % Thêm nhiễu Gaussian vào dữ liệu kiểm tra
%     for q = 1:nTest
%         nPower = mean(abs(H_test(:, :, q)).^2, 'all') / snrTest; % Tính công suất nhiễu
%         HDL_test_n(:, :, q) = H_test(:, :, q) + sqrt(nPower / 2) * (randn(na, nc) + 1i * randn(na, nc)); % Thêm nhiễu Gaussian
%     end
%     Lambda = squeeze(1 ./ mean(abs(HDL_test_n).^2,[1 2])); % Tính lại Lambda
% end
% HDL_test_n = bsxfun(@times, HDL_test_n, reshape(sqrt(Lambda), 1, 1, [])); % Chuẩn hóa ma trận kênh
% HDL_test_compl_tmp = reshape(HDL_test_n, na * nc, nTest).'; % Định dạng lại ma trận kênh
% HDL_test_compl = bsxfun(@minus, HDL_test_compl_tmp, HUL_train_compl_tmp_mean); % Trừ đi giá trị trung bình
% 
% % Lưu các ma trận vào các tệp .mat riêng biệt
% save('HUL_train_compl_tmp.mat', 'HUL_train_compl_tmp', '-v7.3');
% save('HUL_train_compl_tmp_mean.mat', 'HUL_train_compl_tmp_mean', '-v7.3');
% save('HUL_train_compl.mat', 'HUL_train_compl', '-v7.3');
% save('HDL_test_compl_tmp.mat', 'HDL_test_compl_tmp', '-v7.3');
% save('HDL_test_compl.mat', 'HDL_test_compl', '-v7.3');
% 
% disp('Data saved successfully.');

%% Clear workspace and command window
clear; clc;

%% Load các ma trận từ các tệp .mat vào các biến
HUL_train_compl_tmp = load('HUL_train_compl_tmp.mat').HUL_train_compl_tmp;
HUL_train_compl_tmp_mean = load('HUL_train_compl_tmp_mean.mat').HUL_train_compl_tmp_mean;
HUL_train_compl = load('HUL_train_compl.mat').HUL_train_compl;
HDL_test_compl_tmp = load('HDL_test_compl_tmp.mat').HDL_test_compl_tmp;
HDL_test_compl = load('HDL_test_compl.mat').HDL_test_compl;

disp('Data loaded successfully.');

% Sau khi tải dữ liệu, bạn có thể tiếp tục các bước xử lý tiếp theo
% Ví dụ: Thực hiện các bước tiếp theo như huấn luyện mô hình, v.v.



%% Training with CsiNet

fprintf('Training with CsiNet...\n')

% Thiết lập các tham số mạng
maxDelay = 160; % # of OFDM subcarriers
nTx = 64; % # of BS antennas
numChannels = 1; % Số kênh (real và imaginary)
compressRate = 1/16; % Tỉ lệ nén
nTrain = 40000;

% Tạo mô hình mạng CSINet
CSINet = createCSINet(maxDelay, nTx, numChannels, compressRate);

% Phân tích kiến trúc của CSINet
analyzeNetwork(CSINet);

%% Tải dữ liệu huấn luyện
% Định dạng lại dữ liệu huấn luyện
xTrain = reshape(HUL_train_compl.', maxDelay, nTx, numChannels, nTrain);
xTrain = permute(xTrain, [2, 1, 3, 4]); % Định dạng lại để phù hợp với yêu cầu của mạng

% Định dạng lại dữ liệu kiểm tra
xTest = reshape(HDL_test_compl.', maxDelay, nTx, numChannels, nTest);
xTest = permute(xTest, [2, 1, 3, 4]); % Định dạng lại để phù hợp với yêu cầu của mạng

%% Thiết lập các tham số huấn luyện và huấn luyện mạng
options = trainingOptions("adam", ...
    InitialLearnRate = 5e-3, ...
    LearnRateSchedule = "piecewise", ...
    LearnRateDropPeriod = 100, ...
    LearnRateDropFactor = exp(-0.1), ...
    Epsilon = 1e-7, ...
    GradientDecayFactor = 0.9, ...
    SquaredGradientDecayFactor = 0.999, ...
    MaxEpochs = 1500, ...
    MiniBatchSize = 500, ...
    Shuffle = "every-epoch", ...
    Verbose = true, ...
    VerboseFrequency = 400, ...
    ValidationData = {xTest, xTest}, ...
    ValidationFrequency = 400, ...
    OutputNetwork = "best-validation-loss", ...
    Plots = "none");

% Huấn luyện mạng bằng hàm trainNetwork
[CSINet, trainInfo] = trainNetwork(xTrain, xTrain, CSINet, options);

%% Kiểm tra mạng đã được huấn luyện
% Dự đoán giá trị kênh bằng mô hình đã huấn luyện
xHat = predict(CSINet, xTest);

% Chuyển đổi dữ liệu thành dạng phức
xTest_r = HDL_test_compl_tmp(:, 1:na*nc);
xTest_i = HDL_test_compl_tmp(:, na*nc+1:end);
xTestc = complex(xTest_r, xTest_i);

xHat_r = reshape(xHat(:, :, 1, :), [nTest, na*nc]);
xHat_i = reshape(xHat(:, :, 2, :), [nTest, na*nc]);
xHatc = complex(xHat_r, xHat_i);

% Tính toán NMSE
power = sum(abs(xTestc).^2, 2);
nmse = 10.*log10(sum(abs(xTestc - xHatc).^2, 2)./power);
meanNMSE = mean(nmse);
fprintf("\nAt compression rate 1/%d, nmse is %f\n", 1/compressRate, meanNMSE);

% Lưu mô hình đã được huấn luyện
savedNetFileName = "model_CsiNet_dim"+num2str(maxDelay*nTx*numChannels*compressRate)+".mat";
save(savedNetFileName, "CSINet");

%% Hàm phụ trợ tạo mô hình CSINet
function autoencoderLGraph = createCSINet(maxDelay, nTx, numChannels, compressRate)
    inputSize = [maxDelay nTx numChannels];
    numElements = prod(inputSize);
    encodedDim = compressRate*numElements;

    autoencoderLGraph = layerGraph([ ...
        imageInputLayer(inputSize,"Name","Htrunc", "Normalization","none")
        convolution2dLayer([3 3],2,"Padding","same","Name","conv2d")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization")
        leakyReluLayer(0.3,"Name","leaky_re_lu")
        fullyConnectedLayer(encodedDim,"Name","dense")
        fullyConnectedLayer(numElements,"Name","dense_1")
        ]);

    residualLayers1 = [ ...
        convolution2dLayer([3 3],8,"Padding","same","Name","conv2d_1")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_1")
        leakyReluLayer(0.3,"Name","leaky_re_lu_1")
        convolution2dLayer([3 3],16,"Padding","same","Name","conv2d_2")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_2")
        leakyReluLayer(0.3,"Name","leaky_re_lu_2")
        convolution2dLayer([3 3],2,"Padding","same","Name","conv2d_3")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_3")
        additionLayer(2,"Name","add")
        leakyReluLayer(0.3,"Name","leaky_re_lu_3")
        ];

    autoencoderLGraph = addLayers(autoencoderLGraph,residualLayers1);
    autoencoderLGraph = connectLayers(autoencoderLGraph,"dense_1","conv2d_1");
    autoencoderLGraph = connectLayers(autoencoderLGraph,"dense_1","add/in2");

    residualLayers2 = [ ...
        convolution2dLayer([3 3],8,"Padding","same","Name","conv2d_4")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_4")
        leakyReluLayer(0.3,"Name","leaky_re_lu_4")
        convolution2dLayer([3 3],16,"Padding","same","Name","conv2d_5")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_5")
        leakyReluLayer(0.3,"Name","leaky_re_lu_5")
        convolution2dLayer([3 3],2,"Padding","same","Name","conv2d_6")
        batchNormalizationLayer("Epsilon",0.001,"MeanDecay",0.99,"VarianceDecay",0.99,"Name","batch_normalization_6")
        additionLayer(2,"Name","add_1")
        leakyReluLayer(0.3,"Name","leaky_re_lu_6")
        ];

    autoencoderLGraph = addLayers(autoencoderLGraph,residualLayers2);
    autoencoderLGraph = connectLayers(autoencoderLGraph,"leaky_re_lu_3","conv2d_4");
    autoencoderLGraph = connectLayers(autoencoderLGraph,"leaky_re_lu_3","add_1/in2");

    autoencoderLGraph = addLayers(autoencoderLGraph, ...
        [convolution2dLayer([3 3],2,"Padding","same","Name","conv2d_7") ...
        sigmoidLayer("Name","conv2d_7_sigmoid") ...
        regressionLayer("Name","RegressionLayer_conv2d_7")]);

    autoencoderLGraph = connectLayers(autoencoderLGraph,"leaky_re_lu_6","conv2d_7");
end
